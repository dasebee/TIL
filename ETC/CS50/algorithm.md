# 2. 알고리즘 기초

### Topic 1. 알고리즘

**알고리즘** : 컴퓨터 과학에서 알고리즘은 어떤 문제를 단계적으로 풀어가는 명령어의 집합. 문제를 해결하기 위해 입력값을 알고리즘에 넣어주면 알고리즘은 출력값을 준다. 

**알고리즘의 효율성** : 작업을 완료하기까지 얼마나 시간과 노력을 덜 들일 수 있는지에 대한 척도. <u>좋은 알고리즘은 효율성이 좋아야한다.</u> 

**알고리즘의 조건**

+ 입력: 외부에서 제공되는 자료가 0개 이상 존재해야 한다.
+ 출력: 적어도 1개 이상의 서로 다른 결과를 내어야 한다. (모든 입력에 대해서 하나의 출력만이 나와서는 안된다.)
+ 명확성: 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.
+ 유한성(종결성) : 알고리즘의 명령어들은 끝이있는 계산을 수행한 후 종료해야 한다
+ 효율성 : 모든 과정은 명백하게 실행가능한 것이어야 한다.

------------

### Topic 2. 의사코드

알고리즘을 표현하는 방법으로는 자연어, 의사코드, 순서도 등이 있다. 

**의사코드**: 프로그래밍 언어보다 문법적으로 제약을 적게 받으므로 알고리즘 표현에 많이 사용. 기계가 알아들을 수 있도록 사용하는 언어가 아닌 사람이 이해하기 쉬운 언어로 표현하는 것. 생각을 직관적으로 표현하기 위함.  의사코드의 핵심은 <u>발생할 수 있는 모든 경우의 수에 대비</u>하는 것. 

**의사코드의 요소**

의사코드는 프로그래밍 언어와는 다르게 어떻게 작성해야 하는지를 정의한 문법은 없지만, 할당, 반복문, 조건문을 포함하기도 한다. 

```
// 의사코드 예시 : 방에 있는 사람의 수를 세기 위한 알고리즘
let n = 0
for each person in room
	set n = n+1
```

------

### Topic3. 선형탐색

 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 탐색. 찾고자 하는 자료를 찾을 때까지 모든 자료를 확인한다.

정확하지만 비효율적인 방법. 리스트의 길이가 n이라고 했을 때, 최악의 경우(찾고자 하는 요소가 맨 마지막에 있거나 없는경우) n번만큼 실행된다. 

**자료가 정렬되어 있지 않거나 그 어떤 정보도 없이 하나씩 찾아야 하는 경우에 유용**

정렬을 하는 것은 시간이 오래 걸리고 공간을 더 차지하지만, 정렬을 하면 리스트를 검색해야 할 경우 시간을 단축할 수 있다.

--------

### Topic4. 버블 정렬

**두 개의 인접한 자료 값을 비교하고 순서에 맞지 않는다면 위치를 교환**하는 방식으로 정렬하는 방법. 단 두개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다. 간단하지만 하나의 요소를 정렬하기 위해 많은 교환가 낭비가 발생. n개의 요소를 정렬해 주기 위해서 n-1번 실행해아한다. 

버블 정렬 예 :  2,3,4,1 => 2,3,1,4, => 2,1,3,4 => 1,2,3,4  

------------

### Topic5. 선택 정렬

배열 안의 자료 중 가장 작은 수 (혹은 가장 큰 수)를 찾아서 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식. 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가한다. 원래 배열의 순서와 상관없이, 선택 정렬로 정렬되는 배열은 n-1번의 교환이 필요하다. 한 번의 교환이 일어나기 위해서는 정렬되지 않은 수의 모든 비교가 이루어져야 하므로 n번의 비교가 이루어진다. 

선택 정렬 예: 3,1,4,2 => 1,3,4,2 => 1,2,4,3 => 1,2,3,4

----------

### Topic6. 삽입 정렬

정렬되지 않은 부분의 자료가 정렬된 부분의 자리로 삽입되는 형태의 정렬 방법, 자료를 여러 번 비교하거나 교환할 필요가 없다. 특정 실행 단계에서 어떤 원소가 정렬된 배열 내에 자리를 찾았다고 해서 그것이 최종적인 자리라는 보장은 없다. 다음 단계에서 위치가 바뀔 수 있다. 삽입정렬은 자료의 양이 적을 때나 자료의 대부분이 이미 정렬된 경우 효율적. 

삽입 정렬 예: 3,1,4,2 => 3 1,4,2 => 1,3 4,2 => 1,2,3 4 => 1,2,3,4

-----------

### Topic7. 시간 복잡도

**시간복잡도** : 알고리즘을 수행할 때 걸리는 시간을 기준으로 효율성을 분석하는 것. 시간의 효율성이란 알고리즘에서 연산자의 처리 횟수가 적다는 것을 의미. 시간 복잡도가 낮을수록, 연산자의 사용횟수가 적을수록 효율성이 높은 알고리즘이다. 



**Big-O 표기법** : "대략"을 나타내는 개념. 최악의 경우에 대한 시간 복잡도를 나타내는 표현. 

시간복잡도는 <u>가장 중요한(가장 지수가 큰) 부분만 남기고, 계수를 삭제한다.</u> 

+ **선형탐색** : 찾는 값이 배열의 맨 끝에 있는 최악의 상황에서 값을 찾는데 n번의 단계를 거친다 = > **O(n)**
+ **버블정렬** : n개의 자료를 갖는 배열은 n-1쌍을 비교한다. 전체 비교 횟수는 (n-1) + (n-2) + … + 1은 n(n-1)/2이며, n^2/2 - n/2로 나타낼 수 있고, 이것의 가장 중요한 부분은 n^2/2가 되며 (1/2)n^2라고 표현할 수 있다. 계수를 제외하면 n^2가 남고 **O(n^2)**로 표현한다.
+ **선택정렬** : n개의 자료가 있다면 첫 번쨰 자료와 나머지 n-1개의 자료 중 가장 작은 값의 자리를 교환해야한다. 버블 정렬과 마찬가지로 (n-1) + (n-2) + ... + 1 이고 **O(n^2)**로 표현한다.
+ **삽입정렬** : n개의 자료가 있다면 첫번째 자료는 정렬이 되었다고 생각하고, n-1개의 자료 중 첫 번째 자료와 정렬된 자료를 비교한다. 정렬된 자료는 1개이기 떄문에 비교횟수는 1, 정렬되지 않은 부분에 1개의 자료가 남게되면, 정렬된 자료의 수 n-1개 만큼의 비교가 필요하다. 비교 횟수는 1 + 2 + ... + (n-1), 시간 복잡도는 **O(n^2)**이다

**Big Ω 표기법**: Big-O와 비슷한데, 최선의 경우를 나타낸다.

+ **선형 탐색** : 최선의 경우는 배열의 처음에 찾고자 하는 값이 있는 상황. 배열의 크기와 상관 없이 **Ω(1)**
+ **버블 정렬** : 최선의 경우(이미 정렬된 배열)는 교환이 이루어지지 않더라도 배열이 정렬된 사실을 모르기 때문에 n-1번의 비교가 필하기 때문에  **Ω(1)** 이다. 
+ **선택 정렬** : 배열이 정렬되었다는 것을 알 수 없어서 최소값을 계속 찾아주어야 하기 떄문에 **Ω(n^2)** 이다. 
+ **삽입 정렬** : 정렬되지 않은 부분에서 정렬된 부분으로 옮겨갈 때, 정렬된 부분의 가장 큰 수와 비교하기만 하면 되기 때문에 **Ω(n)**이다

-------------

### Topic 8. 합병 정렬

**합병 정렬(병합 정렬)** : 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가는 정렬 방식. 이 과정은 재귀적으로 구현된다. n개의 원소가 있을 때 완전히 나누어지기까지 호출되는 함수의 개수는 log n, 합쳐지는 과정에서 각 원소들의 크기를 비교하기 때문에 n번의 비교 과정이 있다. 한번 나누어질 때마다 n번의 비교횟수가 추가된다. 시간복잡도는 **O(n log n)** 

합병 정렬 예 : 3,4,2,6,4,1 => (3,5,2) , (6,4,1) => ((3,5) 2) , ((6,4),1) => ((3)(5))(2) , ((6)(4))(1) => (3,5),2),(4,6),1) => (2,3,5),(1,4,6) => 1,2,3,4,5,6

----------

### Topic 9. 이진 탐색

**이진 탐색**: 자료를 절반으로 나눈 후 찾는 값이 어느 쪽에 있는지 파악해서 탐색의 범위를 반으로 줄여나가는 탐색 알고리즘, 정렬되어 있는 상황에서 사용된다. 시간복잡도는  **O(log n)** (log n 점점 작아지도록 계속해서 반으로 나누는 것 )

**이진탐색 vs 선형탐색**

이진 탐색은 선형 탐색보다 속도가 짧지만, 배열을 정리하는 정렬 속도가 늘어난다. 그렇기 때문에 선형적으로 배열을 탐색하는 것이 배열을 정렬한 후 이진탐색을 하는 것보다 빠르기도 하다. 배열을 여러 번 탐색한다면 이진 탐색이 유용하다. 